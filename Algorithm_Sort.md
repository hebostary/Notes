- [1. 经典排序算法](#1-%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95)
  - [1.1. 冒泡排序(Bouble Sort)](#11-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8fbouble-sort)
  - [1.2. 插入排序(Insert Sort)](#12-%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8finsert-sort)
  - [1.3. 选择排序(Select Sort)](#13-%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8fselect-sort)
  - [1.4. 冒泡、插入和选择排序的比较](#14-%e5%86%92%e6%b3%a1%e6%8f%92%e5%85%a5%e5%92%8c%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f%e7%9a%84%e6%af%94%e8%be%83)
  - [1.5. 归并排序(Merge Sort)](#15-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8fmerge-sort)
  - [1.6. 快速排序(Quick Sort)](#16-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8fquick-sort)
  - [1.7. 堆排序(Heap Sort)](#17-%e5%a0%86%e6%8e%92%e5%ba%8fheap-sort)
  - [1.8. 希尔排序](#18-%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f)
  - [1.9. 桶排序(Bucket Sort)](#19-%e6%a1%b6%e6%8e%92%e5%ba%8fbucket-sort)
  - [1.10. 计数排序(Counting Sort)](#110-%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8fcounting-sort)
  - [1.11. 基数排序(Radix Sort)](#111-%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8fradix-sort)
- [2. 优先队列](#2-%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97)
  - [2.1. 基础优先队列](#21-%e5%9f%ba%e7%a1%80%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97)
  - [2.2. 堆](#22-%e5%a0%86)
    - [2.2.1. 堆的基本概念](#221-%e5%a0%86%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5)
    - [2.2.2. 堆的基本算法操作](#222-%e5%a0%86%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%ae%97%e6%b3%95%e6%93%8d%e4%bd%9c)
      - [2.2.2.1. 插入元素](#2221-%e6%8f%92%e5%85%a5%e5%85%83%e7%b4%a0)
      - [2.2.2.2. 删除最大元素](#2222-%e5%88%a0%e9%99%a4%e6%9c%80%e5%a4%a7%e5%85%83%e7%b4%a0)
  - [2.3. 堆排序](#23-%e5%a0%86%e6%8e%92%e5%ba%8f)
    - [2.3.1. 堆的构造](#231-%e5%a0%86%e7%9a%84%e6%9e%84%e9%80%a0)
    - [2.3.2. 下沉排序](#232-%e4%b8%8b%e6%b2%89%e6%8e%92%e5%ba%8f)
    - [2.3.3. 复杂度分析](#233-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90)
    - [2.3.4. 为什么快速排序要比堆排序性能好？](#234-%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%e8%a6%81%e6%af%94%e5%a0%86%e6%8e%92%e5%ba%8f%e6%80%a7%e8%83%bd%e5%a5%bd)
  - [2.4. 索引优先队列](#24-%e7%b4%a2%e5%bc%95%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97)
  - [2.5. 优先队列的应用](#25-%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e7%9a%84%e5%ba%94%e7%94%a8)
    - [2.5.1. Top K问题](#251-top-k%e9%97%ae%e9%a2%98)
    - [2.5.2. 多向归并](#252-%e5%a4%9a%e5%90%91%e5%bd%92%e5%b9%b6)
    - [2.5.3. 利用堆求中位数](#253-%e5%88%a9%e7%94%a8%e5%a0%86%e6%b1%82%e4%b8%ad%e4%bd%8d%e6%95%b0)
- [3. 如何选择合适的排序算法](#3-%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95)
  - [理论分析对比](#%e7%90%86%e8%ae%ba%e5%88%86%e6%9e%90%e5%af%b9%e6%af%94)
  - [实际运行性能PK](#%e5%ae%9e%e9%99%85%e8%bf%90%e8%a1%8c%e6%80%a7%e8%83%bdpk)
- [4. 参考链接](#4-%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5)

# 1. 经典排序算法

> 说明：本文是《算法》第四版以及极客时间《数据结构和算法之美》专栏课程的学习笔记。

## 1.1. 冒泡排序(Bouble Sort)

冒泡排序图示

![冒泡排序图示](https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg)

基本思路

- 每一次冒泡的过程就是将一个未排序元素中的最大或者最小的元素一步步地交换到正确的序列位置。

代码实现

```c++
int boublesort(vector<int> &nums) {
    cout<<"***********[Begin]Bouble sort**********"<<endl;
    printVec(nums);
    int size = nums.size();
    if (size < 2) return 0;

    for (int i = size - 1; i >= 0; --i)
    {
        bool flag = false;
        for (int j = 0; j < i; ++j)
        {
            if (nums[j] > nums[j+1]) {
                swap(nums[j], nums[j+1]);
                flag = true;
            }
        }

        //没有数据交换，说明数据已经是有序的，提前退出
        if (!flag) break;
    }

    printVec(nums);
    cout<<"***********[End]Bouble sort**********"<<endl;
    return 0;
}
```

复杂度分析

- 原地排序算法，空间复杂度O(1)。
- 最好情况时间复杂度O(n)：比如[ 1, 2, 3, 4, 5, 6 ]，只需要一次冒泡。
- 最坏情况时间复杂度O(n^2)：比如[ 6, 5, 4, 3, 2, 1 ]，需要n次冒泡。
- 平均情况时间复杂度O(n^2)。
- 稳定性：冒泡排序中，只有后面的元素大于前面的元素时才会做交换，因此不会破坏相同元素原有的相对位置关系，所以冒泡排序是稳定的排序算法。

## 1.2. 插入排序(Insert Sort)

插入排序图示

![插入排序图示](https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg)

基本思路

- 将数组元素分为了两个部分：左边的**已排序区间**和右边的**未排序区间**，遍历时每次从未排序区间取出一个元素插入到已排序区间中的合适位置，每次插入时都可能会搬移大量的元素。

代码实现

```c++
int insertsort(vector<int> &nums) {
    cout<<"***********[Begin]Insert sort**********"<<endl;
    printVec(nums);
    int size = nums.size();
    if (size < 2) return 0;

    for (int i = 1; i < size; ++i)
    {
        int temp = nums[i]; //保存当前要插入的数据
        int j = i - 1;
        for ( ; j >= 0 ; --j) //从后向前遍历已排序区域查找插入位置，同时搬移元素
        {
            if (nums[j] > temp) {
                nums[j+1] = nums[j];
            } else {
                //如果元素相等则不变换已排序元素的位置，保证稳定性
                break;
            }
        }
        //j+1就是最终插入位置
        nums[j+1] = temp;
    }
    printVec(nums);
    cout<<"***********[End]Insert sort**********"<<endl;
    return 0;
}
```

复杂度分析

- 原地排序算法，空间复杂度O(1)。
- 最好情况时间复杂度O(n)：比如[ 1, 2, 3, 4, 5, 6 ]，只需要遍历n个元素，不需要搬移任何数据。
- 最坏情况时间复杂度O(n^2)：比如[ 6, 5, 4, 3, 2, 1 ]，插入每个元素时都需要搬移**已排序区**的所有数据。
- 平均情况时间复杂度O(n^2)。
- 稳定性：在上面的代码实现中，不会破坏相同元素的原来的相对位置，所以插入排序是稳定的排序算法。

## 1.3. 选择排序(Select Sort)

选择排序图示
![选择排序图示](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

基本思路

- 和插入排序类似，将数组元素分为了两个部分：左边的**已排序区间**和右边的**未排序区间**，遍历时每次从未排序区间取出最小元素交换到已排序区间中的尾部。

代码实现

```c++
int selectsort(vector<int> &nums) {
    cout<<"***********[Begin]Select sort**********"<<endl;
    printVec(nums);
    int size = nums.size();
    if (size < 2) return 0;

    for (int i = 0; i < size - 1; ++i)
    {
        int minIndex = i + 1;
        for (int j = i + 2 ; j < size; ++j)
        {
            //找到未排序区里最小元素的索引
            if(nums[j] < nums[minIndex]) minIndex = j;
        }
        //将上面找到的元素交换到排序区的尾部
        if(nums[i] > nums[minIndex]) swap(nums[i], nums[minIndex]);
    }
    printVec(nums);
    cout<<"***********[End]Select sort**********"<<endl;
    return 0;
}
```

复杂度分析

- 原地排序算法，空间复杂度O(1)。
- 最好情况、最坏情况和平均情况的时间复杂度都是O(n^2)。
- 稳定性：因为在交换过程中可能打破相同元素原有的相对位置，所以它不是稳定的排序算法。比如[ 5, 8, 5, 2, 9 ]这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。

## 1.4. 冒泡、插入和选择排序的比较

理论分析比较
![冒泡、插入和选择排序的比较](https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg)

运行效率比较

- 我用前面的代码实现去做10万个随机数的排序，运行时间统计如下，其实无论数据规模多大，三种排序相对时间开销都差不多。显然，在这三种平均时间复杂度均为O(n^2)的排序算法中，插入和选择排序更为高效，因为稳定性原因，插入排序是相对最好的选择。

```sh
***********[Begin]Bouble sort**********
***********[End]Bouble sort**********
Run time: [ 63.670406 ] seconds.
***********[Begin]Insert sort**********
***********[End]Insert sort**********
Run time: [ 17.872087 ] seconds.
***********[Begin]Select sort**********
***********[End]Select sort**********
Run time: [ 24.533143 ] seconds.
```

- 在理论分析上，插入排序和冒泡排序的复杂度是一样的，为什么实际运行效率又会有如此大的差距呢？参考代码实现，原因在于插入排序中的数据移动相比冒泡排序要简单很多，只是简单的将数组元素顺序后移，而冒泡过程中则是大量的swap交换操作，导致每个单元内的耗时更多。

- 即便如此，插入排序也仅适合于小规模数据的排序，因为具有代码实现简单，不占用额外空间的优点，但是随着数据规模增长到一定程度后，也不能再使用这种时间复杂度为O(n^2)的排序算法。

## 1.5. 归并排序(Merge Sort)

归并排序图示
![归并排序图示](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)

基本思路

- 归并排序使用的是**分治思想**，对于这类可以不断分解为子问题的问题，一般用递归来实现，对于递归问题，最重要的是两大要素：**递归公式**和**终止条件**，参考代码实现。**分治是解决问题的处理思想，递归是一种编程技巧。**

代码实现

```c++
int mergesort(vector<int> &nums) {
    cout<<"***********[Begin]Merge sort**********"<<endl;
    printVec(nums);
    int size = nums.size();
    if (size < 2) return 0;

    mergesort_sep(nums, 0, size - 1);
    printVec(nums);
    cout<<"***********[End]Merge sort**********"<<endl;
    return 0;
}

void mergesort_sep(vector<int> &nums, int left, int right) {
    //递归终止条件
    if(left >= right) return;

    int mid = (left + right) / 2;
    mergesort_sep(nums, left, mid);
    mergesort_sep(nums, mid+1, right);
    merge(nums, left, mid+1, right);
}

//合并两段已经排序的子数组：nums[left, mid-1], nums[mid, right]
void merge(vector<int> &nums, int left, int mid, int right) {
    int size = right - left + 1;
    int oriLeft = left; //记录左边子数组的起始下标
    int oriMid = mid;  //记录右边子数组的起始下标
    int k = 0;
    vector<int> tempVec(size); //用一个临时数组来合并两个子数组
    while (left < oriMid && mid <= right)
    {
        tempVec[k++] = (nums[left] <= nums[mid]) ? nums[left++] : nums[mid++];
    }

    //检查两个子数组里哪个还有剩余的数据，如果left=oriMid，说明左边子数组已经全部入列
    int start = (left == oriMid) ? mid : left;
    while (k < size)
    {
        tempVec[k++] = nums[start++];
    }

    //将临时数组里已经排好序的元素写回到原数组中，完成合并
    for (k = 0; k < size; ++k)
    {
        nums[oriLeft + k] = tempVec[k];
    }
}
```

复杂度分析

- 非原地排序算法，在合并过程中用到了额外的数组空间，但是递归过程中使用的最大数组空间为排序数组的大小（注意：完成一次合并后，其中用到的临时数组空间在merge函数返回后就被立即释放了），因此空间复杂度为O(n)。
- 最好情况、最坏情况和平均情况的时间复杂度都是O(nlogn)，**待理解分析过程**。
- 稳定性：合并的过程中可以保证相等元素的原有相对位置，因此是稳定的。

## 1.6. 快速排序(Quick Sort)

快速排序图示

![快速排序图示](https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg)

基本思路

- 快速排序和归并排序类似，也是使用的是**分治思想**。快排先将数组中的所有元素进行分区，分区过程中会选择一个**中心点（pivot）**（比如选择数组的最后一个元素），中心点左边区域的元素都比中心点值小，右边都比它大，之后对中心点左右两个分区继续做类似的处理。
- 参考代码实现，在分区过程中可以通过双指针巧妙地完成元素交换，而不占用额外的空间。

归并快排对比

![归并快排对比](https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg)

快排在原理上和归并排序完全不一样:

- 归并排序是先将问题拆解为同等规模子问题，然后对子问题进行求解（排序），然后逐步合并子问题的解（排序好的子数组）。
- 快排并不是将简单的将问题拆解为同等规模子问题，通过分区操作拆解后的两个子问题具有不同的属性（大小也是随机的），并且分区过程中就逐步完成了数据的移动和排序。

代码实现

```c++
int quicksort(vector<int> &nums) {
    cout<<"***********[Begin]Quick sort**********"<<endl;
    printVec(nums);
    int size = nums.size();
    if (size < 2) return 0;

    quicksort_sep(nums, 0, size - 1);
    printVec(nums);
    cout<<"***********[End]Quick sort**********"<<endl;
    return 0;
}

void quicksort_sep(vector<int> &nums, int left, int right) {
    //递归终止条件
    if(left >= right) return;

    int p = partition(nums, left, right);
    quicksort_sep(nums, left, p - 1);
    quicksort_sep(nums, p + 1, right);
}

//对nums[left, right]区间的元素以nums[right]作为临界值pivot进行分区
//左边分区的元素都小于pivot，右边分区的元素都大于pivot
int partition(vector<int> &nums, int left, int right) {
    int pIndex = left;
    int pivot = nums[right];
    for (int i = left; i < right; ++i)
    {
        //其实这是一个双指针的应用，pIndex始终指向左边分区最后一个大于pivot的元素，
        //也是需要被交换到右边分区的元素，所以i往后遍历时，一旦发现比pivot小的值,
        //则和nums[pIndex]进行交换
        if(nums[i] < pivot) {
            swap(nums[pIndex], nums[i]);
            pIndex += 1;
        }
    }

    swap(nums[pIndex], nums[right]);
    return pIndex;  
}
```

复杂度分析

- 原地排序算法，空间复杂度为O(1)。
- 时间复杂度：在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。
- 稳定性：分区过程中相等元素的原有相对位置可能会改变，因此不是稳定的。

## 1.7. 堆排序(Heap Sort)

因为堆排序需要优先队列和堆的基础知识，在后面一个章节分析。

## 1.8. 希尔排序

希尔排序图示

![基数排序图示]()

基本思路

代码实现

```c++
```

复杂度分析

- 非原地排序算法，空间复杂度为O(n)。
- 时间复杂度：O(n)。
- 稳定性：

适用场景

## 1.9. 桶排序(Bucket Sort)

桶排序图示

![桶排序图示](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg)

基本思路

代码实现

```c++
```

复杂度分析

- 非原地排序算法，空间复杂度为O(n)。
- 时间复杂度：O(n)。
- 稳定性：

适用场景
桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

## 1.10. 计数排序(Counting Sort)

计数排序图示

![计数排序图示](https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg)

基本思路

- 根据上图进行说明，A[8]是需要排序的原数组，C[6]存放的是原数组中小于等于下标值的元素个数（理解数组C中元素值的意义很重要，比如C[2]=4，它代表了原数组中<=2的元素有4个，那么原数组中最后一个2在排序后数组中就应该是第4个，所以下标位置就应该是3），R[8]是用于存放排序结果的临时数组。排序过程：从后往前遍历原数组A[8]，遍历当前值为v，则C[v]-1的值就是v在排序后的数组中的下标位置i,然后将v写入到R[i]，写完值后C[v]需要减一。最后将临时数组的排序结果写会原数组位置即可。

代码实现

```c++
int countingsort(vector<int> &nums) {
    cout<<"***********[Begin]Counting sort**********"<<endl;
    printVec(nums);
    int size = nums.size();
    if (size < 2) return 0;

    //找出数组元素的最大值--确定值范围0 - max
    int max = nums[0];
    for (auto ite = nums.begin(); ite != nums.end(); ++ite)
    {
        if (*ite > max) max = *ite;
    }

    //统计原数组中每个值的个数，值就是countVec的下标
    vector<int> countVec(max + 1, 0);
    for (auto ite = nums.begin(); ite != nums.end(); ++ite)
    {
        countVec[*ite] += 1;
    }

    //累加countVec的值后，原数组中每个值v1作为countVec索引，
    //该位置的值v2代表的就是原数组中 <= v1的元素个数
    for (int i = 1; i < max + 1; ++i)
    {
        countVec[i] += countVec[i - 1];
    }

    //用于临时存放排序的结果
    vector<int> tempVec(size, 0);
    for (int i = size - 1; i >= 0; --i)
    {
        int v = nums[i];
        tempVec[countVec[v] - 1] = v;
        countVec[v] -= 1;
    }

    //将临时排序结果写回原数组
    for (int i = 0; i < size; ++i)
    {
        nums[i] = tempVec[i];
    }

    printVec(nums);
    cout<<"***********[End]Counting sort**********"<<endl;
    return 0;
}
```

复杂度分析

- 非原地排序算法，空间复杂度为O(n)。
- 时间复杂度：O(n)。
- 稳定性：在我们的代码实现中，因为是从后往前完成遍历来查找元素的合适位置，相同元素值的数组索引也是递减的，也就保证了原数组中多个相同的元素值其相对位置关系不会改变，因此是稳定的。

适用场景

- 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
- 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数再排序，但是这个过程又必然增加大量对于计算机比较耗时的乘除运算，所以要更加仔细考虑是否选择计数排序了。

## 1.11. 基数排序(Radix Sort)

基数排序图示
![基数排序图示](https://upload-images.jianshu.io/upload_images/13491454-1d3af296e1793427.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1012)

基本思路

代码实现

```c++
```

复杂度分析

- 非原地排序算法，空间复杂度为O(n)。
- 时间复杂度：O(n)。
- 稳定性：

适用场景

- 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

# 2. 优先队列

先进先出队列（简称队列）是一种基于先进先出（FIFO）策略的集合类型。这里的先仅代表时间上的先后顺序，更早进入队列的元素更早出队列，元素之没有值的关系，也就是无序的。队列最重要的操作包括：

- inset(x)  --插入元素到队尾
- pop()  --弹出一个队首的元素

相对于队列，优先队列定义了不同的操作行为，优先队列中的元素被消费时按照特定的优先级：最先处理当前队列中的最大值（或者最小值）。因此，它最重要的操作是：

- delMax()  --删除最大元素
- insert(x) --插入新的元素

在一些特定的场景下，优先队列可以发挥巨大的作用，后面通过用例来举例使用场景。

## 2.1. 基础优先队列

一般地，优先队列可以基于数组和链表等基础数据结构来实现，下面列出优先队列的各种实现在最坏情况下的时间复杂度。

- 有序数组，插入元素的复杂度为N，删除最大元素的复杂度为1。
- 无序数组，插入元素的复杂度为1，删除最大元素的复杂度为N。
- 堆，插入元素的复杂度为logN，删除最大元素的复杂度为logN。

## 2.2. 堆

### 2.2.1. 堆的基本概念

**堆有序** --当一颗二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。因此，根结点时堆有序的二叉树中的最大结点。注意，堆有序并不能保证对二叉树的遍历能得到有序序列。
**二叉堆（简称堆）** --二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（一般不使用数组的第一个和置）。在一个堆中，位置k的结点的父结点的位置为k/2，左右子结点的位置为2k和2k+1。注意，这里的二叉堆的定义包含下面几个特点，每个特点都有其意义。
- 基于数组实现而不是常用的链表。
- 堆有序。
- 是一颗完全二叉树。非完全二叉树的数组实现会浪费很多存储空间。

堆的例子：
![堆demo](https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg)

### 2.2.2. 堆的基本算法操作

堆可以实现对数级别的**插入元素**和**删除最大元素**的操作，在插入和删除元素的过程中，如何保持二叉树堆有序是最重要的问题，需要依靠堆有序化的操作。
- **大顶堆**  --堆的根结点始终是最大元素，删除操作时是删除最大元素。
- **小顶堆**  --堆的根结点始终是最小元素，删除操作时是删除最小元素。

**由下至上的堆有序化（上浮）**  --如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。
```c++
private void swim(int k) {
    while (k>1 && less(k/2, k)) {
        swap(k/2, k); //交换位置k的结点和它的父结点
        k = k/2; //继续上浮
    }
} 
```

**由上至下的堆有序化（下沉）**  --相反地，如果堆地有序状态因为某个结点变得比它的两个子结点更小了而打破了，那么也可以通过交换它和两个子结点中较大的结点来修复堆。
```c++
private void sink(int k) {
    //N是堆的最大元素个数
    while (2*k < N {
        int j = 2*k;
        if(j < N && less(j, j+1)) j++; //j指向左右子结点中的最大元素
        if(!less(k, j)) break; //已经达到堆有序
        swap(k, j);
        k = j; //继续下沉
    }
} 
```

- 注意，两种堆有序化的方式达到的效果是一样的，但是下沉的堆有序化过程中需要从左右子结点中找出最大的元素，因此，相比上浮的过程多了大概logN次比较。

#### 2.2.2.1. 插入元素

向堆中插入元素时，我们先将新的元素插入到完全二叉树的最左边的空闲叶子结点（堆会记录这个位置），这时堆有序化可能会被打破，然后通过由下至上的堆有序化来修复堆。
![堆insert1](https://static001.geekbang.org/resource/image/e5/22/e578654f930002a140ebcf72b11eb722.jpg)
![堆insert2](https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg)

代码实现
```c++
public void insert(int v) {
    //pq是存储堆的私有数组，N记录了堆的元素个数
    pq[++N] = v; 
    swim(N);
}
```

#### 2.2.2.2. 删除最大元素

删除堆的最大元素实际上就是删除堆的根结点，显然，根结点被删除后需要修复堆。最直观的想法，我们从根结点的左右子结点中选择较大的结点然后和根结点交换，然后继续下沉修复堆。但是，如下图所示，这种方案很容易打破堆的完全二叉树的特性。
![堆delete1](https://static001.geekbang.org/resource/image/59/81/5916121b08da6fc0636edf1fc24b5a81.jpg)
一种比较好的思路是：删除根结点后，把堆的最后一个叶子结点放到根结点的位置，然后再用下沉的方法进行堆有序化，这样就不会破坏堆完全二叉树的特性了。
![堆delete2](https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg)

代码实现
```c++
public int delMax() {
    //pq是存储堆的私有数组，N记录了堆的元素个数
    int max = pq[1];
    swap(1, N--);
    pq[N+1] = null;
    sink(1);
    return max;
}
```

基于堆的优先队列的Java版完整实现 [MaxPQ.java](https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/MaxPQ.java.html)

## 2.3. 堆排序

堆排序分为两个阶段：
1. 堆的构造阶段。目标是在原数组的位置上构造堆，不占用很多额外的空间。
2. 下沉排序结阶段。

### 2.3.1. 堆的构造

最直观的想法就是，从左到右遍历数组，依次把元素插入堆中。更好的思路是利用递归的思想：数组的每个位置都已经是一个子堆的根结点了，如果一个位置k的结点的两个子结点都是一个子堆的根结点了，那么对这个结点调用sink(k)可以将它们合并成一个堆，这个过程可以递归地建立起堆的秩序。因此，**对叶子结点调用sink()函数是没有意义的**，所以我们开始时只需要扫描数组中一半的元素，从N/2的位置开始往左扫描，最后在根结点上调用sink()函数，扫描结束。下面的图展示了这个过程：
![堆的构造1](https://static001.geekbang.org/resource/image/50/1e/50c1e6bc6fe68378d0a66bdccfff441e.jpg)
![堆的构造2](https://static001.geekbang.org/resource/image/aa/9d/aabb8d15b1b92d5e040895589c60419d.jpg)

### 2.3.2. 下沉排序

下沉排序的思路非常简单：依次删除当前堆中的最大元素，然后将删除的元素放入数组最后的空出来的位置。
![堆排序](https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg)

堆排序Java版完整实现 [Heap.java](https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Heap.java.html)

### 2.3.3. 复杂度分析

1. 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。
2. 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。
3. 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

### 2.3.4. 为什么快速排序要比堆排序性能好？
在实际应用中，堆排序很少被使用，它的性能也不如复杂度在同一级别的快速排序：
1. **堆排序数据访问的方式没有快速排序友好。** 对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数组元素很少和相邻的其它元素比较，因此缓存未命中的次数远远高于大多数比较都在相邻元素间进行的算法，比如快排和归并排序。--或者说CPU缓存不友好。
2. **对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。** 我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。

**虽然堆排序很少被使用，但是用堆实现的优先队列在现代应用程序中越来越重要，因为它能在插入操作和删除最大元素操作混合的动态场景中保证对数级别的运行时间。**

## 2.4. 索引优先队列

优先队列存储了程序创建的对象，但同时假设程序不会改变它们，改变它们就可能打破堆有序性。因此，优先队列也存在一些问题：**无法快速访问和修改优先队列中的元素对象**，除非每次遍历整个优先队列，这显然是无法被接受的。
在很多场景中，一个个被插入堆中的元素并不是随机的对象序列，而是本身带有索引的数组元素，而且这些元素的索引还在其它地方被引用，元素和索引有一一对应关系。我们可以在优先队列中存储这样的索引数据，保留原有的索引访问方式，方便快速查找和更新。提供索引方式访问元素的优先队列就是**索引优先队列**。 
索引优先队列的设计思路如下：

![索引优先队列](https://images2015.cnblogs.com/blog/834468/201703/834468-20170326233312658-482268018.jpg)

每次插入堆中的都是一个整数索引和对象的绑定（int i, Key key）：
1. elements[] 根据对象原有的索引（或者一个整数）来存储对象，比例如elements[3] = f。
2. pq[] 还是优先队列，只不过它存储的是元素对象的整数索引i。注意，每次插入或者更新元素对象后，堆有序化过程中比较的都是elements[i]。
3. qp[] 是一个辅助数组，元素初始值为-1。因为对于一个元素的整数索引i，我们并不知道i在堆pq中的存储位置，如果更改了elements[i]后无法高效修复被破坏的堆，除非遍历pq[]。因此我们需要引入一个辅助数组qp来记录i的位置，pq[ qp[j] ] == i， qp[ pq[i] ] == j， 如果qp[i] == -1，则说明i不在队列中。比如我们要找堆中的元素3，则可以通过pq[ qp[3] ] 计算得到。

**索引优先队列API**：
![索引优先队列API](https://images2015.cnblogs.com/blog/833392/201704/833392-20170419164229477-1124896760.png)

索引优先队列的更多细节和完整代码实现参考：
- [索引优先队列的工作原理与简易实现](https://www.cnblogs.com/nullzx/p/6624731.html)
- [IndexMaxPQ.java](https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/IndexMaxPQ.java.html)

## 2.5. 优先队列的应用

### 2.5.1. Top K问题

**典型场景1**：如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？
**解决思路**：我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。

- 如果数组的数据是变化的，我们可以将新的数据或者被更改后的数据统一作为新的数据继续和堆顶元素进行比较。

**典型场景2**：假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？

**解决思路**：

1. 10亿条搜索日志里很可能包含很多重复的搜索关键词，所以首先需要对它们进行统计，这里可以使用散列表这种支持快速查找、插入的数据结构，来记录关键词及其出现的次数，依次遍历所有搜索日志。
2. 根据前面讲的用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。

**如果我们将处理的场景限定为单机，可以使用的内存为 1GB，又该如何解决呢？**
假设90%的重复率， 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了，所以我们无法一次性将所有的搜索关键词加入到内存中。
**改进思路**：

1. 既然内存无法同时加载所有数据，我们可以利用哈希桶来处理，创建10个编号文件01，02，...，然后遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值hash，hash % 10 得到的结果就是这个搜索关键词应该被分到的文件编号（**相同数据经过哈希算法得到的哈希值是一样的**）。10 亿个关键词分片之后，每个文件都只有 1 亿的关键词，去重后就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 500MB，1GB 的内存完全可以放得下。（考虑到每个文件的分布并不一定均匀，可以考虑创建更多的文件）
2. 利用散列表和小顶堆分别取出每个文件里的Top 10，得到100个关键词，然后再取其中Top 10即可。

### 2.5.2. 多向归并

**典型场景1**：假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串，如何将这些 100 个小文件合并成一个有序的大文件？

**解决思路**：类似问题是优先队列的典型使用场景，我们可以初始化一个容量为100的小顶堆，首次先读取每个小文件的第一个字符串，然后删除堆中的最小元素并将其写入合并后的大文件中（当然，不用每个字符串都写文件，可以利用缓冲减少IO次数），假设删除的最小元素来自第5个小文件，那么就需要从该文件读入新的字符串插入到堆中。这就是我们前面在**索引优先队列**里提到的典型场景，堆中的每个字符串元素带有索引信息（属于哪一个小文件），使用索引优先队列，删除最小元素时队列会返回它的索引信息，从而告诉我们从哪个文件读入新的字符串。

### 2.5.3. 利用堆求中位数

**典型场景**：如何求动态数据集合中的中位数？假设数据从0开始编号，n个数据排序后的中位数为：n/2（n为偶数）或者n/2+1（n为奇数）。

![中位数](https://static001.geekbang.org/resource/image/18/b6/1809157fdd804dd40a6a795ec30acbb6.jpg)

**解决思路**：对于一组静态数据，直接先排序即可，但是如果数据集合是动态变化的，那就每次都需要重新排序了，或者找到新数据的插入位置后先搬移后面的所有数据再插入，这些开销都很大。

**如何用堆来求动态数据集合的中位数呢？** 我们可以用一个大顶堆和一个小顶堆来解决这个问题：

- 大顶堆存储数据集合的前半段（较小）数据，小顶堆存储数据集合的后半段数据。如果数据总量n为偶数，两个堆存放的元素量都为n/2；如果n为奇数，大顶堆存放n/2+1个元素。如此，则中位数始终是大顶堆的堆顶元素。
![堆求中位数](https://static001.geekbang.org/resource/image/08/99/08c29d3e014a4baf5f8148c2271e6099.jpg)
- 如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。这样又会打破我们前面说的大顶堆堆顶元素为中位数的规则，所以需要做一些调整：
    1. 如果当前n为偶数：
        1. 新元素需要被插入到大顶堆中，直接插入即可，之后大顶堆存放n/2+1个元素，此时大顶堆堆顶元素依然是中位数。
        2. 新元素需要被插入到小顶堆中，插入后需要删除小顶堆中的堆顶元素a，然后将a插入大顶堆，此时大顶堆堆顶元素依然是中位数。比如：
        ![动态数据集合中位数](https://static001.geekbang.org/resource/image/ae/b1/aee4dcaf9d34111870a1d66a6e109fb1.jpg)
    2. 如果当前n为奇数，做类似的调整即可。

插入数据因为需要涉及堆有序化，所以时间复杂度变成了 O(logn)，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 O(1)。

> 其实求中位数也可以看作求50%位置的“水位”问题，类似的求10%或者99%都可以用同样的思路来解决，无非是小顶堆和大顶堆维护的数据量的比例不同。

# 3. 如何选择合适的排序算法

## 理论分析对比

先来看看前面学习的这几种排序算法的综合对比：

![对比](https://img-blog.csdnimg.cn/20181210101518784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L015cm9uQ2hhbQ==,size_16,color_FFFFFF,t_70)

- 在时间复杂度为O(n^2) 的三种算法中，插入排序显然优于冒泡和选择排序。但是前面也提过，O(n^2)的算法只适用于小规模数据的排序。
- 桶排序、计数排序和基数排序属于线性排序算法，基本上都只有O(n)的时间复杂度，但是仅限于特殊的数据场景，所以不太适用于来写通用的排序函数。
- 为了兼顾任意场景下的数据排序，大多数场景下选择复杂度为O(nlogn)的几种排序算法更为合理。其中，堆排序因为CPU缓存不友好的原因，也很少被使用。实践证明，**快速排序是最快的通用排序算法**，因为它的内循环中的指令很少，而且因为总是顺序访问数据还能利用缓存，所以它的运行时间的增长数量级为~cNlogN，而这里的c比其它线性对数级的排序算法的相应常数都要小。因此，在大多数实际情况中，快速排序是最佳选择。
- **如果稳定性很重要而空间又不是问题，归并排序可能是最好的。**

## 实际运行性能PK

老规矩，针对20万个值范围为1-5000的随机整数数组
排序，冒泡/插入/选择/归并/快排和计数排序的实际性能对比如下：
```sh
***********[Begin]Bouble sort**********
***********[End]Bouble sort**********
Run time: [ 337.790000 ] seconds.
***********[Begin]Insert sort**********
***********[End]Insert sort**********
Run time: [ 84.450000 ] seconds.
***********[Begin]Select sort**********
***********[End]Select sort**********
Run time: [ 121.850000 ] seconds.
***********[Begin]Merge sort**********
***********[End]Merge sort**********
Run time: [ 0.120000 ] seconds.
***********[Begin]Quick sort**********
***********[End]Quick sort**********
Run time: [ 0.070000 ] seconds.
***********[Begin]Counting sort**********
***********[End]Counting sort**********
Run time: [ 0.020000 ] seconds.
```

# 4. 参考链接

[visualgo-算法动态过程演示](https://visualgo.net/en)
