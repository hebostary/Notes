- [1. 查找算法](#1-%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95)
  - [1.1. 二分查找](#11-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be)
    - [1.1.1. 基础二分查找算法](#111-%e5%9f%ba%e7%a1%80%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95)
    - [1.1.2. 二分查找的变体问题](#112-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e7%9a%84%e5%8f%98%e4%bd%93%e9%97%ae%e9%a2%98)
      - [1.1.2.1. 变体问题1：查找第一个值等于给定值的元素](#1121-%e5%8f%98%e4%bd%93%e9%97%ae%e9%a2%981%e6%9f%a5%e6%89%be%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%80%bc%e7%ad%89%e4%ba%8e%e7%bb%99%e5%ae%9a%e5%80%bc%e7%9a%84%e5%85%83%e7%b4%a0)
      - [1.1.2.2. 变体问题2：查找最后一个值等于给定值的元素](#1122-%e5%8f%98%e4%bd%93%e9%97%ae%e9%a2%982%e6%9f%a5%e6%89%be%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e5%80%bc%e7%ad%89%e4%ba%8e%e7%bb%99%e5%ae%9a%e5%80%bc%e7%9a%84%e5%85%83%e7%b4%a0)
      - [1.1.2.3. 变体问题3：查找第一个大于等于给定值的元素](#1123-%e5%8f%98%e4%bd%93%e9%97%ae%e9%a2%983%e6%9f%a5%e6%89%be%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%a4%a7%e4%ba%8e%e7%ad%89%e4%ba%8e%e7%bb%99%e5%ae%9a%e5%80%bc%e7%9a%84%e5%85%83%e7%b4%a0)
      - [1.1.2.4. 变体问题4：查找最后一个小于等于给定值的元素](#1124-%e5%8f%98%e4%bd%93%e9%97%ae%e9%a2%984%e6%9f%a5%e6%89%be%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e5%b0%8f%e4%ba%8e%e7%ad%89%e4%ba%8e%e7%bb%99%e5%ae%9a%e5%80%bc%e7%9a%84%e5%85%83%e7%b4%a0)
  - [1.2. 散列表](#12-%e6%95%a3%e5%88%97%e8%a1%a8)
    - [1.2.1. 散列函数](#121-%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0)
    - [1.2.2. 如何解决散列冲突](#122-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%95%a3%e5%88%97%e5%86%b2%e7%aa%81)
      - [1.2.2.1. 基于拉链法的散列表](#1221-%e5%9f%ba%e4%ba%8e%e6%8b%89%e9%93%be%e6%b3%95%e7%9a%84%e6%95%a3%e5%88%97%e8%a1%a8)
      - [1.2.2.2. 基于线性探测法的散列表](#1222-%e5%9f%ba%e4%ba%8e%e7%ba%bf%e6%80%a7%e6%8e%a2%e6%b5%8b%e6%b3%95%e7%9a%84%e6%95%a3%e5%88%97%e8%a1%a8)
      - [1.2.2.3. 两种散列表使用场景](#1223-%e4%b8%a4%e7%a7%8d%e6%95%a3%e5%88%97%e8%a1%a8%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af)
    - [1.2.3. 散列表动态扩容](#123-%e6%95%a3%e5%88%97%e8%a1%a8%e5%8a%a8%e6%80%81%e6%89%a9%e5%ae%b9)
    - [1.2.4. 评价散列表](#124-%e8%af%84%e4%bb%b7%e6%95%a3%e5%88%97%e8%a1%a8)
  - [1.3. 二叉树](#13-%e4%ba%8c%e5%8f%89%e6%a0%91)
    - [1.3.1. 二叉树基础](#131-%e4%ba%8c%e5%8f%89%e6%a0%91%e5%9f%ba%e7%a1%80)
      - [1.3.1.1. 二叉树存储结构](#1311-%e4%ba%8c%e5%8f%89%e6%a0%91%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84)
      - [1.3.1.2. 二叉树遍历](#1312-%e4%ba%8c%e5%8f%89%e6%a0%91%e9%81%8d%e5%8e%86)
    - [1.3.2. 二叉查找树(Binary Search Tree)](#132-%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91binary-search-tree)
      - [1.3.2.1. 二叉查找树操作](#1321-%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91%e6%93%8d%e4%bd%9c)
      - [1.3.2.2. 代码实现](#1322-%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0)
      - [1.3.2.3. 支持重复数据的二叉查找树](#1323-%e6%94%af%e6%8c%81%e9%87%8d%e5%a4%8d%e6%95%b0%e6%8d%ae%e7%9a%84%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91)
      - [1.3.2.4. 时间复杂度分析](#1324-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90)
    - [1.3.3. 平衡二叉树](#133-%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91)
      - [1.3.3.1. AVL平衡树](#1331-avl%e5%b9%b3%e8%a1%a1%e6%a0%91)
      - [1.3.3.2. 红黑树](#1332-%e7%ba%a2%e9%bb%91%e6%a0%91)
    - [1.3.4. 散列表和二叉查找树的比较](#134-%e6%95%a3%e5%88%97%e8%a1%a8%e5%92%8c%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91%e7%9a%84%e6%af%94%e8%be%83)
  - [1.4. 参考链接](#14-%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5)

# 1. 查找算法

> 说明：本文是《算法》第四版以及极客时间《数据结构和算法之美》专栏课程的学习笔记。

## 1.1. 二分查找

### 1.1.1. 基础二分查找算法

以从有序数组[8，11，19，23，27，33，45，55，67，98]中找出19为例：
![二分查找图示](https://static001.geekbang.org/resource/image/8b/29/8bce81259abf0e9a06f115e22586b829.jpg)

基本原理

- 二分查找的原理很简单（类似于快排中的分区思想，只不过查找的是有序序列），通过与查找区间的中间值比较，不断对半缩小查找区间，使得查找和比较次数大幅减少。

代码实现

```c++
int binarysearch(int *a, int n, int key)
{
    cout<<"***********[Begin]Binary Search**********"<<endl;
    int re = -1;
    int low = 0, high = n - 1, ite = 0;
    while(low <= high) {
        cout<<"Search counter: " << ite++ << endl;
        //mid = (high + low)/2; //high和low都很大时求和容易溢出
        int mid = low + ((high - low)>>1);
        if(key == a[mid]) {
            re =  mid;
            break;
        } else if (key > a[mid]) {
            //注意low和high的更新，如果是low=mid和high=mid，则在low=high时会发生死循环
            low = mid + 1;
        } else {
            high = mid -1;
        }
    }
    if(re == -1) {
        cout<<"Search failed"<<endl;
    }
    cout<<"***********[End]Binary Search**********"<<endl;
    return re;
}
```

复杂度分析

- 二分查找的时间复杂度为**O(logn)**，查找效率非常高。

适用场景

- **因为需要支持根据下标随机访问元素，二分查找依赖于顺序存储结构（数组）。** 那二分查找能否依赖其他数据结构呢？比如链表。NO，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。
- **查找的数组必须是有序的，如果数组是无序的则需要先进行排序。** 如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。
- **需要谨慎地考虑存储空间是否够用。** 尽管数组是最节省内存空间的数据结构（除了元素外不占用额外地空间），但是为了支持随机访问的特性，数组依赖于连续的内存空间。考虑内存使用过程中空闲内存会逐渐碎片化，剩余内存空间并不一定是连续的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。

### 1.1.2. 二分查找的变体问题

#### 1.1.2.1. 变体问题1：查找第一个值等于给定值的元素

代码实现

```c++
int binarysearch_first_euqal(int *a, int n, int key)
{
    int re = -1;
    int low = 0, high = n - 1, ite = 0;
    while(low <= high) {
        cout<<"Search counter: " << ite++ << endl;
        int mid = low + ((high - low)>>1);
        if(key == a[mid]) {
            //mid等于0的时候，意味着数组第一个元素就是我们查找的结果
            //a[mid-1]不等于key的时候，意味着mid位置的元素就是我们要找的结果
            if((mid == 0) || a[mid - 1] != key) {
                re = mid;
                break;
            } else {
                high = mid -1;
            }
        } else if (key > a[mid]) {
            low = mid + 1;
        } else {
            high = mid -1;
        }
    }
    if(re == -1) {
        cout<<"Search failed"<<endl;
    }
    return re;
}
```

#### 1.1.2.2. 变体问题2：查找最后一个值等于给定值的元素

代码实现

```c++
int binarysearch_last_euqal(int *a, int n, int key)
{
    int re = -1;
    int low = 0, high = n - 1, ite = 0;
    while(low <= high) {
        cout<<"Search counter: " << ite++ << endl;
        int mid = low + ((high - low)>>1);
        if(key == a[mid]) {
            //和第一个问题类似，只不过是向数组右边移动判断
            //注意此处，mid一定是和最后的位置n-1比较，而不是查找过程中变化的high
            if((mid == (n - 1)) || a[mid + 1] != key) {
                re = mid;
                break;
            } else {
                low = mid + 1;
            }
        } else if (key > a[mid]) {
            low = mid + 1;
        } else {
            high = mid -1;
        }
    }
    if(re == -1) {
        cout<<"Search failed"<<endl;
    }
    return re;
}
```

#### 1.1.2.3. 变体问题3：查找第一个大于等于给定值的元素

代码实现

```c++
int binarysearch_first_euqal_or_large(int *a, int n, int key)
{
    int re = -1;
    int low = 0, high = n - 1, ite = 0;
    while(low <= high) {
        cout<<"Search counter: " << ite++ << endl;
        int mid = low + ((high - low)>>1);
        if (a[mid] >= key) {
            //继续检查mid左边一位的数组元素,注意数组左边界的检查
            if( (mid == 0) || a[mid - 1] < key) {
                re = mid;
                break;
            } else {
                //mid左边一位仍然大于等于key，则继续迭代查找
                high = mid - 1;
            }
        } else {
            low = mid + 1;
        }
    }
    if(re == -1) {
        cout<<"Search failed"<<endl;
    }
    return re;
}
```

#### 1.1.2.4. 变体问题4：查找最后一个小于等于给定值的元素

代码实现

```c++
int binarysearch_last_euqal_or_small(int *a, int n, int key)
{
    int re = -1;
    int low = 0, high = n - 1, ite = 0;
    while(low <= high) {
        cout<<"Search counter: " << ite++ << endl;
        int mid = low + ((high - low)>>1);
        if (a[mid] <= key) {
            //继续检查mid右边一位的数组元素,注意数组右边界的检查
            if( (mid == (n - 1)) || a[mid + 1] > key) {
                re = mid;
                break;
            } else {
                //mid右边一位仍然小等于key，则继续迭代查找
                low = mid + 1;
            }
        } else {
            high = mid - 1;
        }
    }
    if(re == -1) {
        cout<<"Search failed"<<endl;
    }
    return re;
}
```

## 1.2. 散列表

如果所有的键都是小整数，我们可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中键i处存储的就是它对应的值，这样就可以快速访问（查找）任意的键。这就是散列表（也叫哈希表，Hash Table）的最基本原理：基于数组索引访问的高效性能来实现符号表，可以说散列表是数组的一种扩展。

使用散列的查找算法分两步：
1. 用**散列函数**将被查找的键转化为数组的一个索引，也叫哈希值。理想情况下，不同的键都能转化成不同的索引值。但是实际上，我们不可避免地会遇到不同的键散列到相同的索引值上的情况。
2. 处理**散列冲突**（碰撞冲突）。

散列表是算法在时间和空间上做出权衡的经典案例，因为：
- **如果没有内存限制**，我们可以直接将键作为数组的索引，用足够大的数组来存储下所有的索引数据。比如键的范围为0-10000，那么我们就需要创建一个大小为10000的数组，尽管键的个数可能就100个，此时会有大量的**数组空洞**，因此内存开销非常大。
- **如果没有时间限制**，我们可以用最基础的无序数组来做顺序查找，这样可以只需要很少的内存（没有数组空洞）。
当然，这两种极端情况在实际应用中都不会被容许，而散列表则使用了适度的空间和时间并在这两者时间找到了一种平衡。

### 1.2.1. 散列函数

一个设计良好的散列函数应该具有以下特点：
- **一致性** --等价的键必然产生相等的散列值。
- **高效性** --易于计算。因为每次查找的操作都会先计算散列值，如果散列函数的计算开销很大，就必然会严重影响性能。
- **均匀性** --均匀地散列所的键，即对于任意键，0到M-1之间的每个整数都有相等的可能性与之对应。如果散列函数的得到的索引值分布不够均匀，那么就会频繁地处理散列冲突，并且浪费很多存储空间。

散列函数和键的类型有关。严格地说，对于每种类型的键我们都需要一个与之对应的散列函数。关于散列函数的一些Tips：
> - 如果散列值的计算很耗时，那么我们可以在数据对象中将散列值缓存起来，而不是每次都去计算。
> - 保证均匀性的最好办法也许就是保证**键的每一位**都在散列值的计算中**起到了相同的作用**。比如最常见的散列函数：k % M，用**除留余数法**计算整数k的散列值，如果M不是素数，我们很可能无法利用键中包含的所有信息，这就导致散列不均匀问题。如果键是十进制数而M为10的n次方，那么我们只能利用键的后n位。
> - 实际中，想要找到同时满足3个特点的散列函数是不太可能的。

### 1.2.2. 如何解决散列冲突

#### 1.2.2.1. 基于拉链法的散列表

拉链法解决散列冲突的思想：将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对，同时需要选择足够大的M，使得所有链表都尽可能短以保证高效的查找。

![基于拉链法的散列表](https://algs4.cs.princeton.edu/34hash/images/separate-chaining.png)

**代码实现**：
[SeparateChainingHashST.java](https://algs4.cs.princeton.edu/34hash/SeparateChainingHashST.java.html)

作为优化，我们还可以对拉链法稍加改造，可以实现一个更加高效的散列表。那就是，我们将拉链法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。

#### 1.2.2.2. 基于线性探测法的散列表

实现散列表的另一种方式就是用大小为M的数组保存N个键值对，其中M > N，然后依靠数组中的空位来解决散列冲突，基于这种策略的方法统称为**开放寻址散列表**。
开放地址散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表中的空元素，这些空元素可以作为查找结束的标志。
开放地址散列表中最简单的方法叫做**线性探测法**：
![基于线性探测法的散列表](https://algs4.cs.princeton.edu/34hash/images/linear-probing.png)

基于线性探测的散列表的查找（插入）操作很容易理解，那就是如果散列值i的位置已经有元素了（不等于null），那就向数组右边继续查找，这样的线性探测过程可能会有3种结果：
- **命中**，该位置的键和被查找的键相同，查找结束。
- **未命中**，键为空，查找结束。
- **继续查找**，该位置的键和被查到的键不同，继续探测。

**如何从基于线性探测的散列表中删除元素呢？** 首先，直接把找到的索引位置的元素置为null是不行的，会导致右边的键无法被查找到。因此，我们需要将删除位置右边的所有键重新插入散列表。

**代码实现**：
[LinearProbingHashST.java](https://algs4.cs.princeton.edu/34hash/LinearProbingHashST.java.html)

#### 1.2.2.3. 两种散列表使用场景

- 在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。因此，当数据量比较小、装载因子小的时候，适合采用开放寻址法。
- 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

### 1.2.3. 散列表动态扩容

线性探测的平均成本取决于元素在插入数组后聚集成的一组连续的条目，也叫做**键簇**。显然，短小的键簇才能保证高的效率。如果键簇很长，那么在探测过程中就会多次执行上面的**继续查找**，导致性能下降。基于均匀性的假设，因为数组的每个位置都有相同的可能性被插入一个新键，长键簇的可能性比端键簇更大，因为新键的散列值无论落在簇中的任何位置都会使簇的长度加一。

**装载因子**：N / M，它表示数组的使用率。为了保证性能，对于基于线性探测法的散列表，我们会动态的调整数组的大小来保证装载因子在1/8到1/2之间，这个策略是基于数学上的分析。

为了保证装载因子始终在我们设定的合理范围内，我们需要在装载因子触达阈值之后对数组进行扩容：
1. 申请更大的数组。
2. 将原数组中的键值元素重新散列到新数组中。

![散列表扩容](https://static001.geekbang.org/resource/image/67/43/67d12e07a7d673a9c1d14354ad029443.jpg)

**如何避免低效的扩容**
为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成：
- 当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。
- 当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。
- 这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

![如何避免低效的扩容](https://static001.geekbang.org/resource/image/6d/cb/6d6736f986ec4b75dabc5472965fb9cb.jpg)

通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。

> 我们可以类比分析基于拉链法的散列表，因为散列不均匀或者键值不断增多导致链表过长，从而导致性能下降，其实也可以通过类似的数组扩容策略来解决，只是N / M 的含义变成每条链表的平均长度。

### 1.2.4. 评价散列表

1. 毋庸置疑，散列表的查找性能是非常高效的，达到了理论上的常数级别O(1)。
2. 散列的最主要目的在于均匀地将键散布开来，因此计算后键地顺序信息就丢失了。**如果想要查找最大（最小）的键或者某个范围的键，散列表都不是合适的选择**。我们在后面学习了平衡查找树后会再对比思考这个问题。

## 1.3. 二叉树

### 1.3.1. 二叉树基础

#### 1.3.1.1. 二叉树存储结构

二叉树的存储结构主要有两种：基于链表的**链式存储**和基于数组的**顺序存储**。

链式存储
![二叉树链式存储](https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg)

**链式存储**：每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。大部分二叉树代码都是通过这种结构来实现的，根据实际需要，每个结点上可能还包含更多的数据，比如指向父结点的指针。

顺序存储
![二叉树顺序存储](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg)

基于数组的**顺序存储**：把根节点存储在下标 i = 1 的位置，那左子节点存储在下标2 \* i = 2的位置，右子节点存储在2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。

- 如果节点 X 存储在数组中下标为 i 的位置，下标为 2 \* i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。
- 对于一颗完全二叉树而言，使用顺序存储可以很好的利用空间。

但是，对于如下图的普通二叉树而言，数组中很多空间将会被浪费。
![二叉树顺序存储1](https://static001.geekbang.org/resource/image/08/23/08bd43991561ceeb76679fbb77071223.jpg)

> 优先队列的一种高效实现就是基于顺序存储的二叉树。

#### 1.3.1.2. 二叉树遍历

![二叉树遍历](https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg)

**中序遍历（递归实现）**：

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorderTraversalInner(res, root);
        return res;
    }

    void inorderTraversalInner(vector<int>& res, TreeNode* node) {
        if(node == nullptr) return;
        inorderTraversalInner(res, node->left);
        res.push_back(node->val);
        inorderTraversalInner(res, node->right);
    }
};
```

**中序遍历（迭代实现）**：

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stack;
        TreeNode* currNode = root;
        while(currNode || stack.size()) {
            //从当前结点出发，每次都先将所有左孩子压入栈中
            /* 6, 4, 3这几个结点先被压入栈中，最左边的结点3被访问后，从栈中弹出结点4，
            结点4访问后，因为其还有右孩子，所以继续处理其右子树，逻辑和上面一样
            每个结点只会进栈出栈一次
                    6
                  /   \
                4       8
              /  \     / \
            3     5   7   9
            */
            while(currNode) {
                stack.push(currNode);
                currNode = currNode->left;
            }
            //currNode已经指向null，可以处理栈中的元素了
            currNode = stack.top(); stack.pop();
            res.push_back(currNode->val);
            //继续处理其右子树
            currNode = currNode->right;
        }
        return res;
    }
};
```

### 1.3.2. 二叉查找树(Binary Search Tree)

二叉查找树要求：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。因此，二叉查找树有个很重要的特点：中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。

![二叉查找树](https://static001.geekbang.org/resource/image/f3/ae/f3bb11b6d4a18f95aa19e11f22b99bae.jpg)

#### 1.3.2.1. 二叉查找树操作

**查找元素**:

- 在二叉搜索树中查找元素，其实和二分查找原理是一样的。

**插入元素**:
![二叉查找树插入](https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg)

- 如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

**删除元素**：
![二叉查找树删除](https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg)

删除元素时有3种情况需要处理：

1. 如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。

2. 如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。

3. 如果要删除的节点有两个子节点，我们需要找到这个节点的右子树中的最小节点（或者是左子树的最大节点），把它替换到要删除的节点上。然后再删除掉这个最小节点（或者是最大节点），因为最小节点肯定没有左子节点，所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。

#### 1.3.2.2. 代码实现

[BinarySearchTree.hpp](https://github.com/hebostary/Notes/blob/master/ds-algo/search/src/search/BinarySearchTree.hpp)
```c++
template<class T>
class BinarySearchTree
{
public:
    BinarySearchTree():m_root(NULL){};

    //interfaces
    void Insert (T data);
    BinarySearchTreeNode<T>* Search(T data);

    void PreOrder();
    void InOrder();
    void PostOrder();
 
    //BrnaryTreeNode<T>* MinimumNode();
    //BinarySearchTreeNode<T>* MaxmumNode();

    //T MinmumData();
    //T MaxmumData();

    //void Print();
    void Remove(T data);

    int High();

    //void Destory();

private:
    void insert(BinarySearchTreeNode<T>* &tree, BinarySearchTreeNode<T>* node);
    BinarySearchTreeNode<T>* search(BinarySearchTreeNode<T>* &tree, T data) const;
    void preOrder(BinarySearchTreeNode<T>* &node) const;
    void inOrder(BinarySearchTreeNode<T>* &node) const;
    void postOrder(BinarySearchTreeNode<T>* &node) const;
    //BrnaryTreeNode<T>* minimumNode(BinarySearchTreeNode<T>* &tree);
    //BinarySearchTreeNode<T>* maxmumNode(BinarySearchTreeNode<T>* &tree);
    //void print(BinarySearchTreeNode<T>* &tree);
    void remove(BinarySearchTreeNode<T>* &tree, T data);
    void deleteNode(BinarySearchTreeNode<T>* &node);
    int high(BinarySearchTreeNode<T>* &node);
    //void destory(BinarySearchTreeNode<T>* &tree);

private:
    BinarySearchTreeNode<T> *m_root; //root node
};
```

#### 1.3.2.3. 支持重复数据的二叉查找树

如果存储的两个对象键值相同，这种情况该怎么处理呢？有下面两种思路：

1. 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
2. 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。
![支持重复数据的二叉查找树peg1](https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg)
当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。
![支持重复数据的二叉查找树peg2](https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg)
对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。
![支持重复数据的二叉查找树peg3](https://static001.geekbang.org/resource/image/25/17/254a4800703d31612c0af63870260517.jpg)

#### 1.3.2.4. 时间复杂度分析

![二叉查找树性能](https://static001.geekbang.org/resource/image/e3/d9/e3d9b2977d350526d2156f01960383d9.jpg)

- 对于一颗完全二叉树，不管操作是插入、删除还是查找，查找元素的时间复杂度和有序数组的二分查找是类似的，也就是O(logn)，也就是取决于树的高度。遗憾的是，普通的二叉查找树的性能是很不稳定的，十分依赖于元素的插入删除顺序，很容易退化到链表的时间复杂度O(n)。因此，在实际应用中基本上不会使用这种普通的二叉查找树，而是使用后面介绍的平衡二叉查找树，比如AVL平衡树和红黑树等。

#### 1.3.2.5 验证二叉查找树（Leetcode 98）

利用二叉查找树中序遍历结果结果递增的特点来验证：

```c++
class Solution {
public:
//思路：用迭代的方式左中序遍历，依次遍历到的元素值应该始终是递增的
    bool isValidBST(TreeNode* root) {
        int minValue = INT_MIN;
        int nodeNum = 0;
        stack<TreeNode*> stack;
        TreeNode* p = root;
        while(p || stack.size()) {
            while(p) {
                stack.push(p);
                p = p->left;
            }
            //处理栈中的顶点元素，这个顶点元素的左孩子一定是空的，或者已经被访问过
            p = stack.top(); stack.pop();
            if(nodeNum++ > 0 && p->val <= minValue) return false;
            minValue = p->val;
            //将当前结点的右子树压入栈中
            p = p->right;
        }

        return true;
    }
};
```

### 1.3.3. 平衡二叉树

平衡二叉树的严格定义：二叉树中任意一个节点的左右子树的高度相差不能大于 1。因此，完全二叉树和满二叉树肯定是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。
![平衡二叉树](https://static001.geekbang.org/resource/image/dd/9b/dd9f5a4525f5029a8339c89ad1c8159b.jpg)

#### 1.3.3.1. AVL平衡树

[AVL平衡树插入删除结点过程平衡操作图示](https://blog.csdn.net/u012299594/article/details/84924674)

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。

#### 1.3.3.2. 红黑树

学习红黑树最好先理解2-3查找树，2-3树是一种理论上平衡的二叉查找树，但是由于实际实现起来需要维护不同类型的结点，因此产生的额外开销可能会导致其性能比标准的二叉查找树更慢。红黑树实际上是2-3查找树的演进版本，它将2-3查找树中的3结点用一条红链接及其连接的2个2二结点表示，并且通过一些约束条件使其始终保持2-3查找树的平衡性质。

红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。

关于红黑树的细节参考《算法》第四版3.3节以及[官网动图](https://algs4.cs.princeton.edu/33balanced/)

### 1.3.4. 散列表和二叉查找树的比较

散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？可以从以下几个方面考虑：
1. 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
2. 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
3. 笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
4. 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计（每种键的类型都需要一个优秀的散列函数）、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

综合这几点，平衡二叉查找树在某些方面还是优于散列表的。所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。

## 1.4. 参考链接

[visualgo-算法动态过程演示](https://visualgo.net/en)
